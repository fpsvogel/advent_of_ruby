---
- :name: 7b.rb
  :url: https://github.com/eregon/adventofcode/blob/master/2019
  :solution: "input = File.read('7.txt')\ncode = input.chomp.split(',').map { |e| Integer(e) }.freeze\n\ndef interpreter(memory)\n  memory = memory.dup\n  ip = 0\n  mode = 0\n\n  get_mode = -> i {\n    mode / (10 ** (i-1)) % 10\n  }\n\n  read = -> i {\n    v = memory[ip + i]\n    case m = get_mode[i]\n    when 0\n      memory[v]\n    when 1\n      v\n    else\n      raise \"Unknown read mode #{m} (#{mode} #{i})\"\n    end\n  }\n  \n  write = -> i, result {\n    v = memory[ip + i]\n    case m = get_mode[i]\n    when 0\n      memory[v] = result\n    else\n      raise \"Unknown write mode #{m} (#{mode} #{i})\"\n    end\n  }\n\n  result = nil\n  while true\n    instruction = memory[ip]\n    mode, opcode = instruction.divmod(100)\n    case opcode\n    when 1 # add\n      write[3, read[1] + read[2]]\n      ip += 4\n    when 2 # multiply\n      write[3, read[1] * read[2]]\n      ip += 4\n    when 3 # input\n      write[1, Fiber.yield(result)]\n      ip += 2\n    when 4 # output\n      result = read[1]\n      # just save the result for the next input or halt\n      # Fiber.yield(result)\n      ip += 2\n    when 5 # jump-if-true\n      if read[1] != 0\n        ip = read[2]\n      else\n        ip += 3\n      end\n    when 6 # jump-if-false\n      if read[1] == 0\n        ip = read[2]\n      else\n        ip += 3\n      end\n    when 7 # less than\n      write[3, read[1] < read[2] ? 1 : 0]\n      ip += 4\n    when 8 # equals\n      write[3, read[1] == read[2] ? 1 : 0]\n      ip += 4\n    when 99\n      break\n    else\n      raise \"Unknown opcode: #{opcode} at #{ip} (#{instruction})\"\n    end\n  end\n  result\nend\n\nn = 5\nbest = 0\nbest_phases = nil\nrequire 'fiber'\n\n(5..9).to_a.permutation(n) { |phases|\n  amplifiers = n.times.map { |i|\n    Fiber.new {\n      interpreter(code)\n    }\n  }\n  \n  amplifiers.zip(phases) { |a,phase|\n    a.resume\n    a.resume(phase)\n  }\n  \n  signal = 0\n  while amplifiers.all?(&:alive?)\n    amplifiers.each { |a|\n      signal = a.resume(signal)\n      # continue after ouput instruction\n      # a.resume(:continue)\n    }\n  end\n\n  if signal > best\n    best = signal\n    best_phases = phases.dup\n  end\n}\n\np best\np best_phases"
- :name: 7b_transfer.rb
  :url: https://github.com/eregon/adventofcode/blob/master/2019
  :solution: "input = File.read('7.txt')\ncode = input.chomp.split(',').map { |e| Integer(e) }.freeze\n\ndef interpreter(memory, inputs, output)\n  memory = memory.dup\n  ip = 0\n  mode = 0\n\n  get_mode = -> i {\n    mode / (10 ** (i-1)) % 10\n  }\n\n  read = -> i {\n    v = memory[ip + i]\n    case m = get_mode[i]\n    when 0\n      memory[v]\n    when 1\n      v\n    else\n      raise \"Unknown read mode #{m} (#{mode} #{i})\"\n    end\n  }\n  \n  write = -> i, result {\n    v = memory[ip + i]\n    case m = get_mode[i]\n    when 0\n      memory[v] = result\n    else\n      raise \"Unknown write mode #{m} (#{mode} #{i})\"\n    end\n  }\n  result = nil\n  while true\n    instruction = memory[ip]\n    mode, opcode = instruction.divmod(100)\n    case opcode\n    when 1 # add\n      write[3, read[1] + read[2]]\n      ip += 4\n    when 2 # multiply\n      write[3, read[1] * read[2]]\n      ip += 4\n    when 3 # input\n      input = inputs.shift or raise\n      write[1, input]\n      ip += 2\n    when 4 # output\n      result = read[1]\n      inputs << output.transfer(result) if output.alive?\n      ip += 2\n    when 5 # jump-if-true\n      if read[1] != 0\n        ip = read[2]\n      else\n        ip += 3\n      end\n    when 6 # jump-if-false\n      if read[1] == 0\n        ip = read[2]\n      else\n        ip += 3\n      end\n    when 7 # less than\n      write[3, read[1] < read[2] ? 1 : 0]\n      ip += 4\n    when 8 # equals\n      write[3, read[1] == read[2] ? 1 : 0]\n      ip += 4\n    when 99\n      break\n    else\n      raise \"Unknown opcode: #{opcode} at #{ip} (#{instruction})\"\n    end\n  end\n\n  result # returns to root fiber\nend\n\nn = 5\nbest = 0\nbest_phases = nil\nrequire 'fiber'\n\n(5..9).to_a.permutation(n) { |phases|\n  amplifiers = n.times.map { |i|\n    phase = phases[i]\n    Fiber.new { |signal|\n      interpreter(code, [phase, signal], amplifiers[(i + 1) % n])\n    }\n  }\n\n  signal = 0\n  amplifiers.each { |amplifier|\n    signal = amplifier.transfer(signal)\n  }\n\n  if signal > best\n    best = signal\n    best_phases = phases.dup\n  end\n}\n\np best\np best_phases"
