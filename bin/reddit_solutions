#!/usr/bin/env ruby

require "debug"
require "dotenv"
require "faraday"
require "faraday/retry"
require "pastel"
require "redcarpet"
require "reverse_markdown"
require "thor"
require "yaml"
require_relative "../lib/arb/api/reddit"
require_relative "../lib/arb/version"

# Monkeypatch. Reason: "  \n" is rendered as a line break by Markdown viewers,
# but trailing spaces are annoying and I strip them out because that's what my
# editor does on save anyway. Which leaves only the newline, which is rendered
# as a space. So it's preferable for <br> to become a paragraph break.
module ReverseMarkdown
  module Converters
    class Br < Base
      def convert(node, state = {})
        "\n\n" # CHANGED from "  \n"
      end
    end

    register :br, Br.new
  end
end

# Monkeypatch. Reason: leading spaces are significant for aligning lines of
# code that are indented as well as wrapped in a fenced code block.
module ReverseMarkdown
  module Converters
    class Pre < Base
      def convert(node, state = {})
        content = treat_children(node, state)
        if ReverseMarkdown.config.github_flavored
          # CHANGED from content.strip
          "\n```#{language(node)}\n" << content.chomp << "\n```\n"
        else
          "\n\n    " << content.lines.to_a.join("    ") << "\n\n"
        end
      end

      private

      # Override #treat as proposed in https://github.com/xijo/reverse_markdown/pull/69
      def treat(node, state)
        case node.name
        when 'code', 'text'
          node.text.chomp # CHANGED from node.text.strip
        when 'br'
          "\n"
        else
          super
        end
      end

      def language(node)
        lang = language_from_highlight_class(node)
        lang || language_from_confluence_class(node)
      end

      def language_from_highlight_class(node)
        node.parent['class'].to_s[/highlight-([a-zA-Z0-9]+)/, 1]
      end

      def language_from_confluence_class(node)
        node['class'].to_s[/brush:\s?(:?.*);/, 1]
      end
    end

    register :pre, Pre.new
  end
end


InputError = Class.new(StandardError)

PASTEL = Pastel.new

# AoC Reddit Solutions Downloader CLI application
class RedditSolutionsApp < Thor
  desc "download", "Downloads Reddit solutions for the given language (-l), " \
    "optionally only for the given year (-y) and day (-d), and optionally " \
    "force (-f) overwriting existing files."
  method_option :language, type: :array, aliases: "-l", default: ["ruby"]
  method_option :year, type: :numeric, aliases: "-y"
  method_option :day, type: :numeric, aliases: "-d"
  method_option :force, type: :boolean, aliases: "-f", default: false
  def download
    if options[:day] && options[:year].nil?
      raise InputError, "Year must be specified when day is specified."
    end
    if !options[:year].between?(2015, Date.today.year)
      raise InputError, "Year must be between 2015 and this year."
    end
    if options[:day] && !options[:day].between?(1, 25) && Date.new(options[:year], 12, options[:day]) > Date.today
      raise InputError, "Day must be between 1 and 25, and <= today."
    end

    force_description = PASTEL.red("FORCE ") if options[:force]
    year_description = options[:year].nil? ? "all years" : "#{options[:year]}"
    day_description = options[:day].nil? ? "" : "##{options[:day].to_s.rjust(2, "0")}"
    time_description = PASTEL.blue("#{year_description}#{day_description}")
    language_names = PASTEL.blue(options[:language].join(", "))

    puts "#{force_description}Downloading Reddit solutions from #{time_description} for #{language_names}..."
    puts

    reddit_api_keys = %w[CLIENT_ID CLIENT_SECRET USERNAME PASSWORD]

    Dotenv.load
    Dotenv.require_keys(reddit_api_keys)

    reddit = Arb::Api::Reddit.new(
      client_id: ENV["CLIENT_ID"],
      client_secret: ENV["CLIENT_SECRET"],
      username: ENV["USERNAME"],
      password: ENV["PASSWORD"],
    )

    max_year, max_day = if Date.today.year == options[:year] && Date.today.month == 12
      [Date.today.year, Date.today.day]
    else
      [Date.today.year - 1, 25]
    end

    language_directory = File.join("data", "solutions", "reddit", options[:language].join("-"))
    Dir.mkdir(language_directory) unless Dir.exist?(language_directory)

    (options[:year] || 2015).upto(options[:year] || max_year) do |year|
      year_directory = File.join("data", "solutions", "reddit", options[:language].join("-"), year.to_s)
      Dir.mkdir(year_directory) unless Dir.exist?(year_directory)

      (options[:day] || 1).upto(options[:day] || max_day) do |day|
        path = File.join("data", "solutions", "reddit", options[:language].join("-"), year.to_s, "#{day.to_s.rjust(2, "0")}.yml")

        if File.exist?(path) && !options[:force]
          puts PASTEL.yellow("Skipping #{year}##{day.to_s.rjust(2, "0")} as it already exists.")
          puts
          next
        end

        comments = reddit.get_comments(
          year:,
          day:,
          language_names: options[:language],
        )

        File.write(path, comments.to_yaml(line_width: -1))

        puts "Saved #{PASTEL.blue("#{year}##{day.to_s.rjust(2, "0")}")} to #{path}"
        puts
      end
    end

    # TODO loop through all years and days

    # TODO separately, transform to Markdown:
    #
    # comments = YAML.load_file(...)
    #
    # comments_markdown = comments.map { |comment|
    #   comment_to_markdown(comment)
    # }.join
    #
    # File.write(
    #   ...,
    #   comments_markdown,
    # )
  rescue InputError => e
    puts PASTEL.red(e.message)
  end

  default_task :download

  private

  def comment_to_markdown(comment, level: 0)
    replies = comment[:replies].map { |reply|
      comment_to_str(reply, level: level + 1)
    }.join("\n\n")

    <<~COMMENT.gsub(/(?:\n\s*){3,}/, "\n\n")
      #{"#" * (level + 1)} #{"â†³" * level}#{level.zero? ? "Solution by" : "Reply by"} #{comment[:author]}
      #{comment[:url]}

      #{comment[:body]}

      #{replies unless replies.empty?}
    COMMENT
  end
end

RedditSolutionsApp.start
